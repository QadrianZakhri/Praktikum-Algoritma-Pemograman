 [![UNP](https://unp.ac.id/nfs-assets/all/images/logo_unp_white.png)](https://unp.ac.id/)
# 💫 About Me:
🎓I'm a student at Padang State University<br>💻I'm currently studying programming languages C & Phyton<br>🎮In my free time i like to playing game or hangout<br>


## 🌐 Social Media:
[![Instagram](https://img.shields.io/badge/Instagram-%23E4405F.svg?logo=Instagram&logoColor=white)](https://instagram.com/ryan.zkr) [![TikTok](https://img.shields.io/badge/TikTok-%23000000.svg?logo=TikTok&logoColor=white)](https://tiktok.com/@azuragaksi)

# 💻 Tech Stack:
![C](https://img.shields.io/badge/c-%2300599C.svg?style=for-the-badge&logo=c&logoColor=white) ![C#](https://img.shields.io/badge/c%23-%23239120.svg?style=for-the-badge&logo=c-sharp&logoColor=white) ![C++](https://img.shields.io/badge/c++-%2300599C.svg?style=for-the-badge&logo=c%2B%2B&logoColor=white) ![CSS3](https://img.shields.io/badge/css3-%231572B6.svg?style=for-the-badge&logo=css3&logoColor=white) ![Java](https://img.shields.io/badge/java-%23ED8B00.svg?style=for-the-badge&logo=openjdk&logoColor=white) ![HTML5](https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white) ![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E) ![Python](https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54) ![MySQL](https://img.shields.io/badge/mysql-%2300000f.svg?style=for-the-badge&logo=mysql&logoColor=white) ![Adobe Photoshop](https://img.shields.io/badge/adobe%20photoshop-%2331A8FF.svg?style=for-the-badge&logo=adobe%20photoshop&logoColor=white) ![Canva](https://img.shields.io/badge/Canva-%2300C4CC.svg?style=for-the-badge&logo=Canva&logoColor=white)
# 📊 GitHub Stats:
![](https://github-readme-stats.vercel.app/api?username=QadrianZakhri&theme=ambient_gradient&hide_border=false&include_all_commits=false&count_private=false)<br/>
![](https://github-readme-streak-stats.herokuapp.com/?user=QadrianZakhri&theme=ambient_gradient&hide_border=false)<br/>
![](https://github-readme-stats.vercel.app/api/top-langs/?username=QadrianZakhri&theme=ambient_gradient&hide_border=false&include_all_commits=false&count_private=false&layout=compact)


---
[![](https://visitcount.itsvg.in/api?id=QadrianZakhri&icon=0&color=6)](https://visitcount.itsvg.in)

💻 Kesimpulan Jobsheet</h2>

## Jobsheet 1 Pengenalan Struktur Data
### Struktur Data

Struktur data adalah metode penyimpanan, penyusunan, dan pengaturan data dalam media penyimpanan komputer, sehingga data tersebut dapat diakses dan digunakan dengan efisien. Struktur data umumnya digunakan untuk mengelompokkan beberapa informasi yang terkait menjadi satu kesatuan.

### Jenis-Jenis Struktur Data

Struktur data dapat dibagi menjadi dua kategori utama:

1. **Struktur Data Sederhana:**
   - **Array:** Koleksi elemen yang disimpan dalam urutan tertentu dan memiliki tipe data yang sama.
   - **Record:** Struktur data yang mengelompokkan elemen-elemen dengan tipe data berbeda menjadi satu unit.

2. **Struktur Data Majemuk:**
   - **Linier:**
     - **Stack:** Koleksi elemen yang mengikuti prinsip LIFO (Last In, First Out).
     - **Queue:** Koleksi elemen yang mengikuti prinsip FIFO (First In, First Out).
     - **List dan Multilist:** Variasi dari list yang bisa memiliki berbagai jenis elemen yang terhubung.
   - **Non-Linier:**
     - **Pohon Biner:** Struktur data hierarkis yang terdiri dari node yang masing-masing memiliki maksimum dua anak.
     - **Graph:** Kumpulan node yang saling terhubung dengan edges.

### Tipe Data

Tipe data merujuk pada jenis atau macam data yang dapat disimpan dalam suatu variabel dalam bahasa pemrograman. Contohnya, tipe data dapat disimpan dalam bentuk kode angka, seperti kode ASCII atau kode lainnya. Misalnya, variabel char dengan nilai 'A' disimpan sebagai kode ASCII 65.

### Objek Data

Objek data mengacu pada kumpulan elemen yang unik dan tersimpan sebagai satu kesatuan. Ini berarti setiap objek data adalah unit yang terorganisir dan terstruktur, memungkinkan penyimpanan dan pengaksesan data yang efisien.

### Teknik Pemrograman dan Struktur Data

Dalam teknik pemrograman, struktur data merujuk pada tata letak data yang terdiri dari kolom-kolom. Lebar kolom data dapat bervariasi; beberapa kolom memiliki lebar yang dinamis sesuai masukan pengguna, sementara yang lain memiliki lebar tetap. Penggunaan struktur data yang tepat dapat meningkatkan efisiensi dan efektivitas algoritma pemrograman.

## Jobsheet 2 Array, Pointer, Structure
### Array
Array adalah kumpulan nilai yang memiliki tipe data yang sama. Setiap elemen dalam array dapat diakses menggunakan indeks, memungkinkan akses langsung atau acak ke elemen tersebut.

### Pointer
Pointer adalah variabel yang berisi alamat atau lokasi memori. Pointer dideklarasikan dengan menggunakan simbol asterisk (*) di depan nama variabel sesuai dengan tipe data tertentu. Tidak seperti variabel biasa yang berisi nilai data, pointer menyimpan alamat memori.

#### Tiga Perintah Akses Pointer:
1. Gunakan nama variabel untuk mendapatkan nilai dari variabel pointer.
2. Tambahkan simbol ampersand (&) di depan variabel untuk mendapatkan alamat memori dari variabel tersebut (address of).
3. Tambahkan simbol asterisk (*) di depan variabel untuk mendapatkan nilai dari alamat yang ditunjuk oleh pointer (value pointed by).

### Structure (Struct)
Struct adalah kumpulan variabel yang memiliki tipe data yang berbeda-beda dan dikumpulkan di bawah satu nama objek. Sebelum membuat sebuah struct, perlu untuk menentukan tipe-tipe data apa saja yang akan dimasukkan ke dalamnya.

### Abstract Data Type (ADT) atau Tipe Data Bentukan
ADT adalah koleksi data dan operasi yang dapat digunakan untuk memanipulasi data. ADT didefinisikan oleh pemrogram untuk mempermudah pemrograman dan untuk mengakomodasi tipe-tipe data yang tidak secara khusus didukung oleh bahasa pemrograman yang digunakan.

Dalam bahasa C, terdapat berbagai tipe data termasuk numerik dan karakter seperti int, float, dan char. Selain itu, juga ada tipe data enumerasi dan struktur (structure).

## Jobsheet 3 Single Linked List
### Simpul/Nodes
Simpul atau node berisi alamat dan kumpulan data. Dalam sebuah simpul, keduanya dibungkus menjadi satu objek berupa struct.

### Alokasi Memori
Alokasi memori memberikan fasilitas untuk membuat ukuran buffer dan array secara dinamis, yang berarti ruang dalam memori dialokasikan saat program dijalankan (run time). Ini memungkinkan pengguna untuk membuat tipe data dan struktur dengan ukuran dan panjang sesuai kebutuhan dalam program.

### Perintah sizeof()
Perintah sizeof() digunakan untuk mendapatkan ukuran dari berbagai tipe data, variabel, atau struktur.
- **Return value:** Ukuran dari objek yang bersangkutan dalam byte.
- **Parameter:** Sebuah objek atau sebuah tipe data.

### Perintah malloc()
Perintah malloc() digunakan untuk mengembalikan pointer kosong ke ruang yang telah dialokasikan, atau NULL jika memori yang tersedia tidak mencukupi.

### Linked List
Linked List adalah struktur data yang terdiri dari simpul-simpul atau node-node yang saling terhubung. Setiap simpul dapat menyimpan data dengan tipe yang berbeda-beda, seperti char, int, string, atau tipe data lainnya.

### Single Linked List
Single Linked List adalah jenis linked list yang hanya memiliki satu variabel pointer. Pointer tersebut menunjuk ke node berikutnya dalam list.

## Jobsheet 4 Double Linked List
### Double Linked List (DLL)
Doubly Linked List (DLL) memiliki pointer tambahan yang disebut pointer sebelumnya, selain pointer berikutnya dan data yang ada dalam linked list tunggal. DLL memiliki dua arah data yaitu next dan previous, serta memiliki head dan tail.

### Linked List Kosong
Linked list dianggap kosong jika pointer head berisi NULL. Selain itu, pointer prev dari HEAD selalu NULL karena merupakan data pertama dalam list.

### Kelebihan Double Linked List dibanding Single Linked List
- **Dua Arah:** DLL dapat bergerak dalam dua arah, baik maju maupun mundur.
- **Efisiensi Penghapusan:** Operasi penghapusan atau deletion() lebih efisien dan sederhana karena menggunakan pointer yang menunjuk langsung ke simpul yang akan dihapus.
- **Efisiensi Penyisipan:** Proses insert() simpul lebih efisien karena dapat dilakukan langsung pada posisi yang diinginkan dengan menggunakan pointer.

### Kelemahan Double Linked List
- **Ruang Memori Tambahan:** Setiap simpul dalam DLL memerlukan ruang memori tambahan untuk menyimpan dua pointer.
- **Operasi Kompleks:** Setiap operasi yang dilakukan harus menyertakan pointer ke simpul sebelumnya, yang dapat menambah kompleksitas.

## Jobsheet 5 Double and Circular Linked List
### Double Linked List
Double Linked List adalah struktur data di mana setiap elemen terhubung dengan dua pointer dalam satu node, memungkinkan traversal baik ke depan (next) maupun ke belakang (prev).

Setiap node dalam double linked list memiliki tiga field:
1. Field yang menunjuk ke node berikutnya (next).
2. Field yang menunjuk ke node sebelumnya (prev).
3. Field yang berisi data untuk node tersebut.

Untuk menunjukkan awal dari double linked list, pointer prev dari elemen pertama menunjuk ke NULL. Sedangkan untuk menunjukkan akhir dari double linked list, pointer next dari elemen terakhir menunjuk ke NULL.

### Circular Linked List
Circular Linked List adalah jenis linked list yang tidak memiliki elemen tail. Dalam circular linked list, pointer next dari elemen terakhir menunjuk kembali ke elemen pertama, bukan ke NULL. Dalam double linked circular list, pointer prev dari elemen pertama menunjuk ke elemen terakhir, membentuk struktur melingkar.

## Jobsheet 6 Stack
### Stack
Stack adalah struktur data di mana setiap elemen data ditempatkan di atas elemen lainnya, mengikuti aturan LIFO (Last In First Out). Ini berarti elemen terakhir yang dimasukkan ke dalam stack akan menjadi elemen pertama yang diambil.

### Push
Push adalah operasi yang digunakan untuk menambahkan elemen baru ke dalam stack. Elemen baru selalu ditempatkan di posisi paling atas dari stack.

### Pop
Pop adalah operasi yang digunakan untuk menghapus elemen yang berada di posisi paling atas dari stack.

### Peek
Peek adalah operasi yang digunakan untuk memeriksa elemen paling atas tanpa menghapusnya dari stack.

### isFull
isFull adalah metode yang digunakan untuk memeriksa apakah stack sudah penuh. Ini dilakukan dengan menambah satu (increment) nilai TOP of STACK setiap kali ada penambahan elemen ke stack selama stack belum penuh, kemudian mengisi nilai baru ke stack berdasarkan indeks TOP of STACK yang telah ditambah satu.

### isEmpty
isEmpty adalah metode yang digunakan untuk memeriksa apakah stack kosong. Ini dilakukan dengan memeriksa nilai TOP of STACK. Jika nilai TOP masih -1, maka stack dianggap kosong.

### Clear
Clear adalah operasi yang digunakan untuk mengosongkan seluruh isi stack.

## Jobsheet 7 Queue
### Queue (Antrian)
Queue adalah bentuk khusus dari List Linier di mana operasi penyisipan (insertion) hanya diperbolehkan pada satu sisi, yaitu sisi belakang (REAR), dan operasi penghapusan (deletion) hanya diperbolehkan pada sisi lainnya, yaitu sisi depan (FRONT).

### Prinsip FIFO
Prinsip dasar dari struktur data ini adalah “First In, First Out” (FIFO), yang berarti elemen data yang pertama kali dimasukkan ke dalam antrean akan menjadi yang pertama kali dikeluarkan.

### Fungsi Utama Queue
Queue berfungsi untuk mengatur dan mengelola antrean tugas atau operasi secara efisien. Dalam sistem komputasi, queue digunakan untuk menangani tugas-tugas seperti penjadwalan proses, antrean pesan, dan manajemen sumber daya.

### Terminologi Queue
Urutan pertama yang akan dikeluarkan disebut Front atau Head. Sebaliknya, data yang baru saja ditambahkan ke urutan terakhir disebut Back, Rear, atau Tail.

### Operasi pada Queue
- **Enqueue**: Proses menambahkan data ke dalam antrean.
- **Dequeue**: Proses menghapus data dari antrean.

## Jobsheet 8 Bubble and Insertion Sort
### Sorting (Pengurutan)
Sorting adalah proses mengatur data yang awalnya disusun secara acak menjadi teratur menurut aturan tertentu.

### Teknik Sorting yang Umum Digunakan
Beberapa teknik sorting yang sering digunakan meliputi bubble sort, insertion sort, selection sort, quicksort, mergesort, heapsort, dan binary sort.

### Bubble Sort
Bubble sort adalah metode pengurutan yang bekerja dengan menukar data yang berdekatan terus-menerus hingga dalam satu iterasi tertentu tidak ada lagi perubahan. Jika tidak ada perubahan, maka data dianggap sudah terurut. Dinamakan bubble sort karena elemen kunci akan perlahan naik ke posisinya yang tepat seperti gelembung.

### Insertion Sort
Insertion sort adalah teknik pengurutan dengan cara membandingkan dan mengurutkan dua elemen pertama pada array, kemudian membandingkan elemen berikutnya untuk menempatkannya di posisi yang semestinya. Algoritma ini mirip dengan proses mengurutkan kartu di tangan kita.

## Jobsheet 9 Selection and Merge Sort
### Selection Sort
Selection sort adalah algoritma yang digunakan untuk mencari dan memilih elemen terkecil dalam sebuah list yang belum terurut pada setiap iterasi, kemudian menempatkan elemen terkecil tersebut di urutan paling depan.

#### Cara Kerja Selection Sort:
1. Tetapkan elemen pertama sebagai elemen terkecil dan jadikan sebagai "minimum".
2. Bandingkan elemen minimum dengan elemen kedua. Jika elemen kedua lebih kecil, jadikan elemen kedua sebagai minimum. Lanjutkan membandingkan minimum dengan elemen berikutnya hingga elemen terakhir.
3. Setelah setiap perulangan, elemen minimum ditempatkan di urutan paling depan dari list.
4. Pada setiap pengulangan, indeksasi dimulai dari elemen pertama. Langkah 1-3 diulangi hingga semua elemen berada di posisi yang terurut.

### Merge Sort
Merge sort adalah algoritma pengurutan yang bekerja dengan membagi daftar menjadi beberapa subdaftar hingga masing-masing hanya memiliki satu item, lalu menggabungkan subdaftar tersebut menjadi daftar yang terurut.

#### Cara Kerja Merge Sort:
1. **Divide**: Bagilah masalah menjadi beberapa bagian kecil dari masalah yang sama.
2. **Conquer**: Pecahkan submasalah dengan menyelesaikannya secara rekursif. Selesaikan submasalah sebagai kasus dasar jika submasalah tersebut cukup kecil.
3. **Combine**: Untuk menemukan solusi dari masalah awal, gabungkan solusi dari submasalah yang telah diselesaikan.

## Jobsheet 10 Shell and Quick Sort
### Shell Sort
Shell Sort adalah algoritma pengurutan yang membandingkan dan mengurutkan elemen-elemen yang memiliki jarak interval tertentu. Prinsip dasarnya mirip dengan Insertion Sort, tetapi lebih efisien untuk daftar yang lebih besar.

#### Cara Kerja Shell Sort:
1. Elemen-elemen dalam array diurutkan dengan jarak interval tertentu.
2. Interval antara elemen yang dibandingkan dan diurutkan semakin kecil seiring dengan pengulangan pengurutan.
3. Pada fase awal, jika ukuran array N=8, maka interval dihitung dengan rumus N/2 = 4. Elemen-elemen dengan jarak interval 4 dibandingkan dan ditukar jika tidak terurut.
4. Pada pengulangan berikutnya, interval dihitung dengan rumus N/4 = 8/4 = 2. Elemen-elemen dengan jarak interval 2 dibandingkan dan ditukar jika perlu.
5. Proses ini dilanjutkan hingga interval menjadi 1, di mana elemen-elemen yang bersebelahan diurutkan.

### Quick Sort
Quick Sort adalah algoritma pengurutan yang memilih sebuah elemen sebagai pivot dan memisahkan array di sekitarnya berdasarkan pivot tersebut.

#### Cara Kerja Quick Sort:
1. Algoritma ini memilih sebuah elemen sebagai pivot.
2. Array dipecah menjadi dua bagian: elemen-elemen yang lebih kecil dari pivot ditempatkan di sebelah kiri pivot, dan elemen-elemen yang lebih besar ditempatkan di sebelah kanan pivot.
3. Fungsi partisi() adalah proses utama dalam quickSort. Tujuannya adalah menempatkan pivot pada posisi yang benar dalam array yang diurutkan, dan menempatkan elemen yang lebih kecil di sebelah kiri dan yang lebih besar di sebelah kanan pivot.
4. Partisi dilakukan secara rekursif pada setiap sisi pivot setelah pivot ditempatkan pada posisi yang benar, hingga seluruh array terurut.

## Jobsheet 11  Linear and Binary Search
### Algoritma Pencarian

Algoritma pencarian adalah sebuah metode yang menerima argumen kunci dan melakukan serangkaian langkah untuk menemukan rekaman yang sesuai dengan kunci tersebut. Hasil dari pencarian ini bisa berupa data yang ditemukan (berhasil) atau tidak ditemukan (gagal).

#### Linear Search
Linear Search adalah metode pencarian yang berjalan secara berurutan dari satu ujung ke ujung lainnya dalam daftar elemen. Algoritma ini memeriksa setiap elemen satu per satu hingga menemukan elemen yang dicari atau hingga mencapai akhir daftar.

Proses Linear Search melibatkan iterasi melalui semua elemen array dan membandingkan setiap elemen dengan elemen target. Jika elemen yang dicari ditemukan, algoritma mengembalikan indeks elemen tersebut. Jika tidak, algoritma mengembalikan -1 untuk menunjukkan bahwa elemen tidak ditemukan.

#### Binary Search
Binary Search adalah algoritma pencarian yang efisien untuk menemukan posisi nilai target dalam array yang sudah diurutkan. Algoritma ini bekerja dengan cara membagi interval pencarian menjadi dua bagian terus menerus sampai nilai target ditemukan atau interval tersebut menjadi kosong.

Langkah-langkah Binary Search:
1. Tentukan rentang pencarian dari posisi pertama hingga posisi terakhir (N).
2. Hitung posisi tengah dengan rumus: `(posisi awal + posisi akhir) / 2`.
3. Bandingkan nilai target dengan nilai di posisi tengah:
   - Jika sama, maka pencarian selesai dan elemen ditemukan.
   - Jika nilai target lebih besar, lanjutkan pencarian dengan rentang baru dari posisi tengah + 1 hingga posisi akhir.
   - Jika nilai target lebih kecil, lanjutkan pencarian dengan rentang baru dari posisi awal hingga posisi tengah - 1.

Dengan cara ini, Binary Search mengurangi separuh rentang pencarian di setiap langkah, membuatnya lebih efisien dibandingkan Linear Search terutama pada data yang besar.

## Jobsheet 12 Tree
### Tree Traversal

Tree Traversal adalah proses mengunjungi semua simpul (node) dalam sebuah pohon data (tree).

Setiap pohon adalah kombinasi dari sebuah simpul utama yang menyimpan data dan dua sub-pohon (sub-tree).

Berdasarkan urutan kunjungannya, terdapat tiga metode traversal dalam pohon:

#### Inorder Traversal
Langkah-langkahnya:
1. Kunjungi semua simpul di sub-pohon sebelah kiri.
2. Kunjungi simpul root (simpul utama).
3. Kunjungi semua simpul di sub-pohon sebelah kanan.

#### Preorder Traversal
Langkah-langkahnya:
1. Kunjungi simpul root terlebih dahulu.
2. Kunjungi semua simpul di sub-pohon sebelah kiri.
3. Kunjungi semua simpul di sub-pohon sebelah kanan.

#### Postorder Traversal
Langkah-langkahnya:
1. Kunjungi semua simpul di sub-pohon sebelah kiri.
2. Kunjungi semua simpul di sub-pohon sebelah kanan.
3. Terakhir, kunjungi simpul root.

## Jobsheet 13 Graphs
### Breadth-First Search (BFS)
Breadth-First Search (BFS) adalah teknik yang berbasis simpul untuk mencari jalur terpendek dalam sebuah graf. Metode ini menggunakan struktur data Antrian (Queue) yang mengikuti prinsip first in first out (FIFO).

**Cara kerja BFS:**
1. Pilih satu simpul pada suatu waktu, kunjungi dan tandai simpul tersebut.
2. Kunjungi dan simpan simpul-simpul yang berdekatan dalam antrian.

### Depth First Search (DFS)
Depth First Search (DFS) adalah teknik yang berbasis tepi (edge) dan menggunakan struktur data Tumpukan (Stack). DFS dilakukan dalam dua tahap utama:

1. Masukkan simpul yang dikunjungi pertama ke dalam tumpukan.
2. Jika tidak ada simpul yang tersisa, tampilkan simpul yang dikunjungi.

**Cara kerja algoritma DFS:**
1. Mulailah dengan meletakkan salah satu simpul dari graf ke dalam tumpukan.
2. Ambil item teratas dari tumpukan dan tambahkan ke daftar simpul yang telah dikunjungi.
3. Buatlah daftar dari simpul-simpul yang terhubung langsung dengan simpul tersebut. Tambahkan simpul yang belum dikunjungi ke bagian atas tumpukan.
4. Ulangi langkah 2 dan 3 sampai tumpukan menjadi kosong.


<!-- Proudly created with GPRM ( https://gprm.itsvg.in ) -->

<!--Footer--> 
<p align="center">
  <img src="https://capsule-render.vercel.app/api?type=waving&color=gradient&height=65&section=footer"/>
</p>





